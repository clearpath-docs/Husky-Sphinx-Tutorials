



<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Husky Outdoor GPS Waypoint Navigation &mdash; Husky UGV Tutorials 0.5.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/clearpath.css" type="text/css" />
  

  
    <link rel="top" title="Husky UGV Tutorials 0.5.1 documentation" href="index.html"/>
        <link rel="next" title="Husky UR5 Mobile Manipulation Demo (Simulation)" href="HuskyManip.html"/>
        <link rel="prev" title="Husky Frontier Exploration Demo" href="HuskyFrontiers.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

  <!-- Start of clearpathrobotics Zendesk Widget script -->
<script>/*<![CDATA[​*/window.zEmbed||function(e,t){var n,o,d,i,s,a=[],r=document.createElement("iframe");window.zEmbed=function(){a.push(arguments)},window.zE=window.zE||window.zEmbed,r.src="javascript:false",r.title="",r.role="presentation",(r.frameElement||r).style.cssText="display: none",d=document.getElementsByTagName("script"),d=d[d.length-1],d.parentNode.insertBefore(r,d),i=r.contentWindow,s=i.document;try{o=s}catch(c){n=document.domain,r.src='javascript:var d=document.open();d.domain="'+n+'";void(0);',o=s}o.open()._l=function(){var o=this.createElement("script");n&&(this.domain=n),o.id="js-iframe-async",o.src=e,this.t=+new Date,this.zendeskHost=t,this.zEQueue=a,this.body.appendChild(o)},o.write('<body onload="document._l();">'),o.close()}("https://assets.zendesk.com/embeddable_framework/main.js","clearpathrobotics.zendesk.com");/*​]]>*/</script>
<!-- End of clearpathrobotics Zendesk Widget script -->

<script>
 (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
 (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
 m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
 })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

 ga('create', 'UA-65409991-1', 'auto');
 ga('send', 'pageview');

</script>


</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Husky UGV Tutorials
          

          
            
            <img src="_static/clearpathlogo.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.5.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search..." />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="BackUpHusky.html">Backing Up Husky Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="InstallHuskySoftware.html">Install and Configure Husky Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="CustomizeHuskyConfig.html">Customize Husky Configuration</a></li>
</ul>
<p class="caption"><span class="caption-text">Using Husky</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="SimulatingHusky.html">Simulating Husky</a></li>
<li class="toctree-l1"><a class="reference internal" href="InterfacingWithHusky.html">Interfacing with Husky</a></li>
</ul>
<p class="caption"><span class="caption-text">Demo Applications: Navigation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="HuskyMove.html">Husky Move Base Demo</a></li>
<li class="toctree-l1"><a class="reference internal" href="HuskyAMCL.html">Husky AMCL Demo</a></li>
<li class="toctree-l1"><a class="reference internal" href="HuskyGmapping.html">Husky Gmapping Demo</a></li>
<li class="toctree-l1"><a class="reference internal" href="HuskyFrontiers.html">Husky Frontier Exploration Demo</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Husky Outdoor GPS Waypoint Navigation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#installing-software">Installing Software</a></li>
<li class="toctree-l2"><a class="reference internal" href="#understanding-the-software">Understanding the Software</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-the-simulation">Running the Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-and-configuring-your-husky">Building and Configuring your Husky</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performing-gps-waypoint-navigation-on-your-husky">Performing GPS Waypoint Navigation on your Husky</a></li>
<li class="toctree-l2"><a class="reference internal" href="#continuous-gps-waypoint-navigation">Continuous GPS Waypoint Navigation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#common-problems">Common Problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#waypoint-mapping-with-mandala-mapping">Waypoint Mapping with Mandala-Mapping</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Demo Applications: Manipulation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="HuskyManip.html">Husky UR5 Mobile Manipulation Demo (Simulation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="HuskyDualManip.html">Husky Dual UR5 Mobile Manipulation Demo (Simulation)</a></li>
</ul>
<p class="caption"><span class="caption-text">Package Components</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="HuskyPackages.html">Husky Packages</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Husky UGV Tutorials</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
     
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="http://support.clearpathrobotics.com">Home</a> &raquo;</li>
      
    <li>Husky Outdoor GPS Waypoint Navigation</li>
      <li class="wy-breadcrumbs-aside">
        <div class="roslogo">
      </div>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="husky-outdoor-gps-waypoint-navigation">
<h1>Husky Outdoor GPS Waypoint Navigation<a class="headerlink" href="#husky-outdoor-gps-waypoint-navigation" title="Permalink to this headline">¶</a></h1>
<p>This tutorial demonstrates how to use the <a class="reference external" href="https://github.com/nickcharron/waypoint_nav">waypoint_nav</a> package to perform autonomous GPS waypoint navigation on an outdoor Husky and in simulation. It requires a GPS, IMU and a front facing lidar.</p>
<dl class="docutils">
<dt>This package uses a combination of the following packages:</dt>
<dd><ul class="first last simple">
<li>ekf_localization to fuse odometry data with IMU and GPS data</li>
<li>navsat_transform to convert GPS data to odometry and to convert latitude and longitude points to the robot&#8217;s odometry coordinate system</li>
<li>GMapping to create a map and detect obstacles</li>
<li>move_base to navigate to the goals while avoiding obstacles (goals are set using recorded or inputted waypoints)</li>
</ul>
</dd>
<dt>The outdoor_waypoint_nav package within waypoint_nav includes the following custom nodes:</dt>
<dd><ul class="first last simple">
<li>gps_waypoint to read the waypoint file, convert waypoints to points in the map frame and then send the goals to move_base</li>
<li>gps_waypoint_continuous1 and gps_waypoint_continuous2 for continuous navigation between waypoints using two seperate controllers</li>
<li>collect_gps_waypoint to allow the user to drive the robot around and collect their own waypoints</li>
<li>calibrate_heading to set the heading of the robot at startup and fix issues with poor magnetometer data</li>
<li>plot_gps_waypoints to save raw data from the GPS for plotting purposes</li>
<li>gps_waypoint_mapping to combine waypoint navigation with Mandala Robotics&#8217; 3D mapping software for autonomous 3D mapping</li>
</ul>
</dd>
</dl>
<div class="section" id="installing-software">
<h2>Installing Software<a class="headerlink" href="#installing-software" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Visit the <a class="reference external" href="https://github.com/nickcharron/waypoint_nav">waypoing_nav</a> Github Repo and select <strong>copy link</strong> or <strong>download zip</strong></li>
<li>Clone repo or unzip folder to your ~/catkin_ws/src/ directory (or to the source folder of your catkin workspace)</li>
<li>Ensure you have all necessary packages:</li>
</ol>
<blockquote>
<div><div class="code bash highlight-python"><div class="highlight"><pre>$ sudo apt-get install ros-indigo-gazebo-*
</pre></div>
</div>
<div class="code bash highlight-python"><div class="highlight"><pre>$ sudo apt-get install ros-indigo-husky-*
</pre></div>
</div>
<div class="code bash highlight-python"><div class="highlight"><pre>$ sudo apt-get install ros-indigo-robot-localization
</pre></div>
</div>
<div class="code bash highlight-python"><div class="highlight"><pre>$ sudo apt-get install ros-indigo-move-base
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="4">
<li>Compile:</li>
</ol>
<blockquote>
<div><div class="code bash highlight-python"><div class="highlight"><pre>$ cd ~/catkin_ws/
</pre></div>
</div>
<div class="code bash highlight-python"><div class="highlight"><pre>$ catkin_make
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="understanding-the-software">
<h2>Understanding the Software<a class="headerlink" href="#understanding-the-software" title="Permalink to this headline">¶</a></h2>
<p>There are two components to the waypoint navigation that you need to run. The first launch file (outdoor_waypoint_nav_sim.launch) launches the simulation, teleop, rviz as well as your localization, mapping and controller packages. This will not make the robot move but it will continue to update its estimated state and maps.</p>
<p>Let&#8217;s discuss what each package is doing:</p>
<blockquote>
<div><p><strong>robot_localization</strong> is used to fuse all your sensor data using two separate ekf_localization nodes. One ekf node, named ekf_se_odom, is used to filter all the continuous data, i.e. IMU and wheel odometry. The second ekf node, named ekf_se_map, is used to fuse discrete data (GPS) along with other sources of data. Furthermore, the navsat_transform node is used to convert the raw GPS data into odometry messages that can then inputted into the ekf, while also publishing the transform from the UTM coordinate frame to the robot&#8217;s odometry frame. The ekf_se_odom node publishes the TF transform from odom frame to the base_link frame (this needs to be continuous) whereas the ekf_se_map publishes the TF transform from the map frame to the odom frame. Since the latter is discrete due to the discrete measurements coming from your GPS, your robot&#8217;s estimated state will jump around slightly when it is visualized in RVIZ. Visit <a class="reference external" href="http://docs.ros.org/lunar/api/robot_localization/html/index.html">robot_localization</a> for additional information.</p>
<p><strong>GMapping</strong> is used to create the map that will be used for navigation. It should be noted that the transform from the map frame to the odom frame from GMapping is not used. We cannot have two nodes publishing the same transform, therefore we want to use the transform from the ekf node not from GMapping. For more information, see the <a class="reference external" href="http://wiki.ros.org/gmapping">GMapping ROS Wiki</a> , or <a class="reference external" href="http://openslam.org/gmapping.html">GMapping Documentation</a></p>
</div></blockquote>
<p>The second component that needs to be launched is the joystick launch controller (joy_launch_control.launch). You will need to plug in a controller for this simulation to work. The joy_launch_control node subscribes to messages from the joystick and controls what nodes are launched and shut down. Launching this node will also not make your robot move until you start to press buttons on the joystick.</p>
<p>There are 4 launch files that can be launched, shutdown and re-launched using the joystick:</p>
<blockquote>
<div><ol class="arabic simple">
<li><strong>safety_node.launch</strong>: remaps velocity commands outputted from move_base to the correct topic name for the husky velocity controller. This allows the user to safely stop the robot motion at any time by killing this node.</li>
<li><strong>heading_calibration.launch</strong>: drives the husky forward a given distance and rate and calculates the heading error at startup. The robot will then return to its initial location and write the heading offset to the navsat params file.</li>
<li><strong>collect_goals.launch</strong>: allows the user to drive the Husky around while collecting gps waypoints. It saves these waypoints (as latitude and longitude coordates) to a text file that can be saved and played back.</li>
<li><strong>send_goals.launch</strong>: reads the gps coordinates from a text file, converts those coordinates to move_base goals and publishes them. The text file that is read can be the file that was created with the collect_goals node, or the text file can be created manually by retrieving gps coordinates from another source.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="running-the-simulation">
<h2>Running the Simulation<a class="headerlink" href="#running-the-simulation" title="Permalink to this headline">¶</a></h2>
<p>First launch the localization, mapping and planning nodes:</p>
<div class="code bash highlight-python"><div class="highlight"><pre>$ roslaunch outdoor_waypoint_nav outdoor_waypoint_nav_sim.launch
</pre></div>
</div>
<p>You should have two displays that appear, Gazebo and RVIZ:</p>
<img alt="_images/HuskyGPSWaypointNav_Gazebo.png" src="_images/HuskyGPSWaypointNav_Gazebo.png" />
<img alt="_images/HuskyGPSWaypointNav_RVIZ.png" src="_images/HuskyGPSWaypointNav_RVIZ.png" />
<p>Before running the joystick launch controller, please configure your launch file for your specific controller. Using your favourite editor, open:</p>
<div class="code bash highlight-python"><div class="highlight"><pre>~/catkin_ws/src/wapoint_nav/outdoor_waypoint_nav/launch/simulation/joy_launch_control_sim.launch
</pre></div>
</div>
<p>Edit the arguments to set your joystick buttons to what you want. You may need to launch the teleop joystick package to view which buttons are mapped to which number. These arguments are set by default to work with a Logitech F710 joystick (in x mode).</p>
<p>Launch the joystick controller:</p>
<div class="code bash highlight-python"><div class="highlight"><pre>$ roslaunch outdoor_waypoint_nav  joy_launch_control_sim.launch
</pre></div>
</div>
<p>On your screen, it will remind you what buttons need to be selected to perform each task:</p>
<img alt="_images/HuskyGPSWaypointNav_joy_launch_control.png" src="_images/HuskyGPSWaypointNav_joy_launch_control.png" />
<p>You can now drive your Husky around to collect waypoints, and then follow those same waypoints that were just collected.</p>
<p><strong>Simulation Results</strong></p>
<p>The following <a class="reference external" href="http://embed.vidyard.com/share/1EGdVBFCLbB5Dqh1n7GvdE?">video</a> shows the results of running the simulation as described above:</p>
<object width="576" height="462"><param name="movie"
value="https://play.vidyard.com/1EGdVBFCLbB5Dqh1n7GvdE.html?v=3.1.1"></param><param
name="allowFullScreen" value="true"></param><param
name="allowscriptaccess" value="always"></param><embed
src="https://play.vidyard.com/1EGdVBFCLbB5Dqh1n7GvdE.html?v=3.1.1"
allowscriptaccess="always"
allowfullscreen="true" width="576"
height="462" style="padding: 0px 0px 20px 0px;"></embed></object></div>
<div class="section" id="building-and-configuring-your-husky">
<h2>Building and Configuring your Husky<a class="headerlink" href="#building-and-configuring-your-husky" title="Permalink to this headline">¶</a></h2>
<p>Based on the type of GPS and IMU you are using, you may have to change several files. Once your sensors have been mounted to your Husky, measure their location and orientation with respect to the base_link coordinate frame. Update the URDF with these new measurements. The URDF can be found at:</p>
<div class="code bash highlight-python"><div class="highlight"><pre>/waypoint_nav/husky_customization/husky_custom_description/urdf/custom_description.urdf.xacro
</pre></div>
</div>
<p>For help editing the URDF, refer to the <a class="reference external" href="http://wiki.ros.org/urdf/Tutorials">ROS URDF Tutorials</a>
. You can find a sketch showing the dimensions of the Husky <a class="reference external" href="https://www.clearpathrobotics.com/husky-unmanned-ground-vehicle-robot/">here</a> . The base_link coordinate frame is located in the middle of the bottom plate.</p>
<p><strong>Important Note:</strong> since robot_state_publisher already publishes a transform to your imu_link based on the environmental variables describing the IMU pose, the easiest way to set the pose of your IMU is by changing the environmental variables. For simplicity, we use a bash script that will export the appropriate environmental variables each time you start your navigation. Based on your measurements, edit the bash script located at:</p>
<div class="code bash highlight-python"><div class="highlight"><pre>/waypoint_nav/outdoor_waypoint_nav/run.sh
</pre></div>
</div>
<p>Next, you will need to edit the launch files that bring up your sensor drivers. Navigate to the following directory:</p>
<div class="code bash highlight-python"><div class="highlight"><pre>/waypoint_nav/outdoor_waypoint_nav/launch/include
</pre></div>
</div>
<p>Edit the <strong>imu.launch</strong>, <strong>gps.launch</strong> and <strong>laser.launch</strong> files to bringup the appropriate drivers. The default is configured to work with a UM6 IMU, NovAtel SMART6-L GPS and Sick LMS111 laser scanner. Be sure they are publishing to the correct topics, and set the appropriate IP address for your laser.</p>
</div>
<div class="section" id="performing-gps-waypoint-navigation-on-your-husky">
<h2>Performing GPS Waypoint Navigation on your Husky<a class="headerlink" href="#performing-gps-waypoint-navigation-on-your-husky" title="Permalink to this headline">¶</a></h2>
<p>If all your sensors are publishing to the same topics as the default simulation from waypoint_nav, and your frame IDs are set the same, then launching outdoor_waypoint_nav.launch should start up your eks nodes, navsat node, and move_base properly. Make sure your GPS is outdoor and unobstructed before launching so that it can get a fix, otherwise the navsat node will not initialize properly.</p>
<p>On your robot computer, launch the localization, mapping and planning nodes <strong>using your bash script</strong> (do not just launch the file directly using roslaunch):</p>
<div class="code bash highlight-python"><div class="highlight"><pre>$ ./run.sh
</pre></div>
</div>
<p>Next, in another terminal run the joy_launch_control node:</p>
<div class="code bash highlight-python"><div class="highlight"><pre>$ roslaunch outdoor_waypoint_nav  joy_launch_control.launch
</pre></div>
</div>
<img alt="_images/HuskyGPSWaypointNav_allignment1.png" src="_images/HuskyGPSWaypointNav_allignment1.png" />
<p>To run the calibration node, first close all your nodes and relaunch. Make sure your Husky has at least 5m of space in front of it for calibration. You can edit the distance and speed that the robot drives by changing the x_vel and x_vel_time parameters. Those can be set in your terminal when running the launch file, or it can be changed by editing the heading_calibration.launch file.</p>
<p>On the joystick, press the button that starts calibration (START button by default). You should see:</p>
<img alt="_images/HuskyGPSWaypointNav_calibration1.png" src="_images/HuskyGPSWaypointNav_calibration1.png" />
<p>Your robot will move forward the specified distance, and then return to its initial location while writing the heading calibration to the navsat params file. Your screen output should be similar to:</p>
<img alt="_images/HuskyGPSWaypointNav_calibration2.png" src="_images/HuskyGPSWaypointNav_calibration2.png" />
<p>You will need to restart the ekf nodes to load the new heading parameters. You may need to repeat this calibration multiple times until you are happy with the heading alignment shown in RVIZ. It is recommended to repeat this procedure every time you start your robot with a new heading. Alternatively, you can manually set the start position (refer to <a class="reference external" href="http://docs.ros.org/lunar/api/robot_localization/html/integrating_gps.html#required-inputs">robot_localization docs</a> )</p>
<p>You are now ready to collect waypoints or follow waypoints. The collect_gps_waypoint node will save the collected waypoints to the same text file that the gps_waypoint node will read from. This file can be manually changed if you want to input your own gps coordinates. This coordinates file is located at:</p>
<div class="code bash highlight-python"><div class="highlight"><pre>/waypoint_nav/outdoor_waypoint_nav/waypoint_files/points_outdoor.txt
</pre></div>
</div>
<p>and for simulation:</p>
<div class="code bash highlight-python"><div class="highlight"><pre>/waypoint_nav/outdoor_waypoint_nav/waypoint_files/points_sim.txt
</pre></div>
</div>
<p>To start waypoint collection, press the start collection button (LB by default). You can then drive around collecting waypoints along your path. Make sure to end the node with the joystick, then launch the waypoint following node (RB button by default).</p>
<p>The following <a class="reference external" href="http://embed.vidyard.com/share/mS1S2t6kEQZ3YkY4bPAuyc?">video</a> illustrates an implementation of this software on one of our own Husky&#8217;s:</p>
<object width="576" height="462"><param name="movie"
value="https://play.vidyard.com/mS1S2t6kEQZ3YkY4bPAuyc.html?v=3.1.1"></param><param
name="allowFullScreen" value="true"></param><param
name="allowscriptaccess" value="always"></param><embed
src="https://play.vidyard.com/mS1S2t6kEQZ3YkY4bPAuyc.html?v=3.1.1"
allowscriptaccess="always"
allowfullscreen="true" width="576"
height="462" style="padding: 0px 0px 20px 0px;"></embed></object></div>
<div class="section" id="continuous-gps-waypoint-navigation">
<h2>Continuous GPS Waypoint Navigation<a class="headerlink" href="#continuous-gps-waypoint-navigation" title="Permalink to this headline">¶</a></h2>
<p>We have also developed separate software that allows you to navigate between each waypoint without stopping. This has all be integrated into the <a class="reference external" href="https://github.com/nickcharron/waypoint_nav">waypoint_nav repo</a>.</p>
<p>This software works by using two separate move_base nodes (named controller_1 and controller_2) that run simultaneously. The waypoints are fed to the controllers such that each controller gets every other waypoint. Say the robot is currently navigating to goal 3 with controller 1. When the robot approaches the goal, it tells controller 2 that it should start planning its route to goal 4. Once controller 2 has planned its route and starts publishing its velocity commands, the switch_controller node detects these commands and switches the control from controller 1 to controller 2 and then cancels the goal that was given to controller 1. Controller 1 then waits for the signal from controller 2 to start planning to the next goal, and so on.</p>
<p>The parameter <strong>goalTolerance</strong> controls how close the robot needs to be to its goal to send a start signal to the next controller. You can edit this parameter in the send_goals_continuous.launch file located at:</p>
<div class="code bash highlight-python"><div class="highlight"><pre>/waypoint_nav/outdoor_waypoint_nav/launch/include
</pre></div>
</div>
<p>We have provided an outdoor_waypoint_nav_continuous.launch file and a joy_launch_controller_continuous.launch file as well as the equivalent launch files for simulation. Simply start those launch files instead of the ones specified above, and you&#8217;re done. Remember that if you are running the software on your real Husky, use the bash sript to launch the main launch file. In this case, use the run_continuous.sh script.</p>
<p>The following video &lt;<a class="reference external" href="http://embed.vidyard.com/share/1EGdVBFCLbB5Dqh1n7GvdE">http://embed.vidyard.com/share/1EGdVBFCLbB5Dqh1n7GvdE</a>?&gt;`_ illustrates the continuous waypoint following in action:</p>
<object width="576" height="462"><param name="movie"
value="https://play.vidyard.com/1EGdVBFCLbB5Dqh1n7GvdE.html?v=3.1.1"></param><param
name="allowFullScreen" value="true"></param><param
name="allowscriptaccess" value="always"></param><embed
src="https://play.vidyard.com/1EGdVBFCLbB5Dqh1n7GvdE.html?v=3.1.1"
allowscriptaccess="always"
allowfullscreen="true" width="576"
height="462" style="padding: 0px 0px 20px 0px;"></embed></object></div>
<div class="section" id="common-problems">
<h2>Common Problems<a class="headerlink" href="#common-problems" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><dl class="first docutils">
<dt>Husky base not launching</dt>
<dd><ul class="first last simple">
<li>These packages have all been built assuming that you already have husky_base running when you power on your robot. If this is not the case, you will either need to launch husky_base on your own, or uncomment the lines in the main launch files that include the husky_base launch file.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Unable to reach goal</dt>
<dd><ul class="first last">
<li><p class="first">Reason 1: Often you will notice that you robot stops moving in the middle of navigation. A common reason for this is if you are in rough terrain and your laser hits the ground and interprets it as an obstacle. This can occur even in relatively flat grass. Confirm this is the reason by launch rviz and visualizing the global and local costmaps.</p>
</li>
<li><p class="first">Solution: filter your laser measurements to a lesser maximum usable range. This can be done with a laser filter nodelet (see laser.launch) or by changing your parameters in the GMapping launch file.</p>
</li>
<li><p class="first">Reason 2: Other times, your robot might not move at all when it is given to a new goal. This is usually the case when the goal is set to a location that cannot be reached according to your global planner. If the goal is in a location outside of the global costmap, or somewhere wihthin an obstacle, then your global planner will be unable to plan a route.</p>
</li>
<li><p class="first">Solution: If your goal is outside your global costmap, increase the costmap size by edditing:</p>
<blockquote>
<div><div class="code bash highlight-python"><div class="highlight"><pre>/waypoint_nav/husky_navigation/params/global_costmap_params.yaml
</pre></div>
</div>
<p>If your goal is within an obstacle, either change your goal or change the default_tolerance parameter and move_base will get as close as it can to the goal.</p>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Robot moving too slow</dt>
<dd><ul class="first last">
<li><p class="first">The velocity can be changed within your move_base params. Edit:</p>
<blockquote>
<div><div class="code bash highlight-python"><div class="highlight"><pre>/waypoint_nav/husky_navigation/params/base_local_planner_params.yaml
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Do not set the min_vel_x lower than 0.1. Sending velocity commands that are very low will not result in enough voltage going to the motors to actually overcome the friction of the tires. Therefore move_base will get &#8220;stuck&#8221;.</p>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Unable to navigate around obstacles</dt>
<dd><ul class="first last">
<li><p class="first">There are many parameters that you can tune with the move_base planner. You may need to adjust these if your robot is not properly planning routes around obstacles. This planning is done in the local planner.</p>
</li>
<li><p class="first">Edit the base_local_planner_params file. See the comments in the yaml file for a description of these parameters.</p>
</li>
<li><p class="first">Common parameters to tune: vx_samples, vtheta_samples, controller_frequency</p>
</li>
<li><p class="first">It also might be helpful to tune the costmap parameters such as the inflation_radius and cost_scaling_factor found in:</p>
<blockquote>
<div><div class="code bash highlight-python"><div class="highlight"><pre>/waypoint_nav/husky_navigation/params/costmap_common_params.yaml
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Robot continually rotating about its goal</dt>
<dd><ul class="first last simple">
<li>Sometimes the Husky will continue to try to adjust its position to get to the exact goal location.</li>
<li>Solution: increase the xy_goal_tolerance and/or yaw_goal_tolerance in base_local_planner.yaml</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Improper Initialization:</dt>
<dd><ul class="first last simple">
<li>The navsat_transform_node takes care of creating the transform from the world frame to the odom frame. It does this using absolute position data at start-up. In our case, it uses the x and y pose from the GPS and the Yaw from the IMU&#8217;s magnetometer. Since these measurements are noisy and biased, often this will cause error in the transform that is used for the whole navigation of your robot.</li>
<li>This is a known issue with navsat_transform. For now, we recommend restarting all your nodes when really poor initialization occurs. We are currently working on a solution that determines the start point of your robot by filtering your data over a given distance. Please have a look at the READ_ME file in the github repository for notes on when that has been fixed and how to use the new feature.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Localization Accuracy:</dt>
<dd><ul class="first last simple">
<li>You may notice that when navigating to waypoints that you have collected, your robot might not end up within the distance tolerance that you have set for the goal, whereas in simulation this will likely not be an issue.</li>
<li>Reason: Extended Kalman Filters (EKFs) such as the ones used in this package, assume that measurements are Gaussian with a zero mean noise. In Gazebo, the GPS data is simulated using a zero mean Gaussian distribution, so the EKF will perform really well. However, GPS signals are neither Gaussian nor do they have noise with zero mean. Therefore you should expect to see more error in your outdoor navigation compared to your simulated navigation</li>
<li>If you would like to visualise the data from your GPS and compare that to the simulated data, a node named plot_gps_waypoints has been created in the outdoor_waypoint_nav package that allows you to collect and store raw GPS data for plotting purposes.</li>
<li>The following two images show the GPS data from simulation compared to the data collected using a NovAtel SMART6-L. Both datasets show 700 points taken at 0.1 Hz. The covariances for simulation were set in Gazebo to be equal to the calculated covariances from the Novatel GPS data.</li>
</ul>
</dd>
</dl>
</li>
</ol>
<img alt="_images/GPS_data_Sim_Low_Cov.jpg" src="_images/GPS_data_Sim_Low_Cov.jpg" />
<img alt="_images/GPS_data_Novatel_d.jpg" src="_images/GPS_data_Novatel_d.jpg" />
<p>Note: The Novatel GPS discretizes its own data which explains the grid pattern that is seen in the above image. To visualize the quantity of data points at each location, the size of the points has been scaled according to the quantity of data points per location.</p>
<p>The following image shows data collected at the same rate using a Garmin GPS18x-5Hz:</p>
<img alt="_images/GPS_data_Garmin_a.jpg" src="_images/GPS_data_Garmin_a.jpg" />
</div>
<div class="section" id="waypoint-mapping-with-mandala-mapping">
<h2>Waypoint Mapping with Mandala-Mapping<a class="headerlink" href="#waypoint-mapping-with-mandala-mapping" title="Permalink to this headline">¶</a></h2>
<p>For those with the 3D Mapping kit from <a class="reference external" href="http://mandalarobotics.com/">Mandala-Robotics</a> , we have also provided a node and launch files to perform waypoint navigation and mapping simultaneously. To add this to your robot:</p>
<ol class="arabic">
<li><p class="first">Visit the <a class="reference external" href="https://github.com/nickcharron/mandala-mapping">Mandala-Mapping repo</a> and copy link</p>
</li>
<li><p class="first">Clone to your workspace and build:</p>
<blockquote>
<div><div class="code bash highlight-python"><div class="highlight"><pre>$ cd ~/catkin_ws/src
</pre></div>
</div>
<div class="code bash highlight-python"><div class="highlight"><pre>$ git clone &lt;paste link&gt;
</pre></div>
</div>
<div class="code bash highlight-python"><div class="highlight"><pre>$ cd ~/catkin_ws
</pre></div>
</div>
<div class="code bash highlight-python"><div class="highlight"><pre>$ catkin_make
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">In one terminal, run the waypoint navigation</p>
<blockquote>
<div><div class="code bash highlight-python"><div class="highlight"><pre>$ cd ~/catkin_ws/src/waypoint_nav/outdoor_waypoint_nav/
</pre></div>
</div>
<div class="code bash highlight-python"><div class="highlight"><pre>$ ./run.sh
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">In another terminal, run the joystick launch controller (specific launch file for mapping)</p>
<blockquote>
<div><div class="code bash highlight-python"><div class="highlight"><pre>$ roslaunch outdoor_waypoint_nav joy_launch_control_mapping.launch
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">In a third terminal, run the mapping:</p>
<blockquote>
<div><div class="code bash highlight-python"><div class="highlight"><pre>$ roslaunch m3d_husky_launch m3d_husky_bringup.launch
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Follow the instructions in the joy_launch_control_mapping terminal.</p>
</li>
</ol>
<p>Your Husky will automatically collect a scan at each waypoint that it reaches, so take this into consideration when setting your waypoints. We recommend moving no more than 3 meters between scans to ensure successful scan matching. Scanmatching results will also depend on your environment and the range of your lasers. If your 3D map does not appear to be built accurately enough, you may need a better rotating lidar or an environment with more features. You can also increase the density of the 3D map by moving in smaller increments between your scans. For more information, take a look at the <a class="reference external" href="https://www.clearpathrobotics.com/2017/07/rapid-outdoorindoor-3d-mapping-husky-ugv/">mapping blog post</a>.</p>
<p>The following <a class="reference external" href="http://embed.vidyard.com/share/5sMjrx8sUmNMaHwyj7yFwc?">video</a> shows the autonomous GPS waypoing mapping in action to map the Clearpath parking lot and part of the building:</p>
<object width="576" height="462"><param name="movie"
value="https://play.vidyard.com/5sMjrx8sUmNMaHwyj7yFwc.html?v=3.1.1"></param><param
name="allowFullScreen" value="true"></param><param
name="allowscriptaccess" value="always"></param><embed
src="https://play.vidyard.com/5sMjrx8sUmNMaHwyj7yFwc.html?v=3.1.1"
allowscriptaccess="always"
allowfullscreen="true" width="576"
height="462" style="padding: 0px 0px 20px 0px;"></embed></object></div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="HuskyManip.html" class="btn btn-neutral float-right" title="Husky UR5 Mobile Manipulation Demo (Simulation)" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="HuskyFrontiers.html" class="btn btn-neutral" title="Husky Frontier Exploration Demo" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Clearpath Robotics.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.5.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>